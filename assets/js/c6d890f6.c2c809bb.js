"use strict";(self.webpackChunkdocsite_poc_github_io=self.webpackChunkdocsite_poc_github_io||[]).push([[52453],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),f=o,m=p["".concat(s,".").concat(f)]||p[f]||d[f]||i;return n?a.createElement(m,r(r({ref:t},u),{},{components:n})):a.createElement(m,r({ref:t},u))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(67294),o=n(86010);const i="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,r),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>f});var a=n(87462),o=n(67294),i=n(86010),r=n(72389),l=n(67392),s=n(7094),c=n(12466);const u="tabList__CuJ",d="tabItem_LNqP";function p(e){var t,n;const{lazy:r,block:p,defaultValue:f,values:m,groupId:h,className:g}=e,k=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),b=null!=m?m:k.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),w=(0,l.l)(b,((e,t)=>e.value===t.value));if(w.length>0)throw new Error('Docusaurus error: Duplicate values "'+w.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const C=null===f?f:null!=(t=null!=f?f:null==(n=k.find((e=>e.props.default)))?void 0:n.props.value)?t:k[0].props.value;if(null!==C&&!b.some((e=>e.value===C)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+C+'" but none of its children has the corresponding value. Available values are: '+b.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:v,setTabGroupChoices:y}=(0,s.U)(),[N,T]=(0,o.useState)(C),I=[],{blockElementScrollPositionUntilNextRender:S}=(0,c.o5)();if(null!=h){const e=v[h];null!=e&&e!==N&&b.some((t=>t.value===e))&&T(e)}const x=e=>{const t=e.currentTarget,n=I.indexOf(t),a=b[n].value;a!==N&&(S(t),T(a),null!=h&&y(h,String(a)))},O=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=I.indexOf(e.currentTarget)+1;n=null!=(a=I[t])?a:I[0];break}case"ArrowLeft":{var o;const t=I.indexOf(e.currentTarget)-1;n=null!=(o=I[t])?o:I[I.length-1];break}}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,i.Z)("tabs-container",u)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":p},g)},b.map((e=>{let{value:t,label:n,attributes:r}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:e=>I.push(e),onKeyDown:O,onFocus:x,onClick:x},r,{className:(0,i.Z)("tabs__item",d,null==r?void 0:r.className,{"tabs__item--active":N===t})}),null!=n?n:t)}))),r?(0,o.cloneElement)(k.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==N})))))}function f(e){const t=(0,r.Z)();return o.createElement(p,(0,a.Z)({key:String(t)},e))}},54612:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>f,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var a=n(87462),o=(n(67294),n(3905)),i=n(65488),r=n(85162);const l={title:"Set up the remote configuration",date:"2022-08-30",sidebar_position:50},s="Set up the remote configuration",c={unversionedId:"collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration/index",id:"collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration/index",title:"Set up the remote configuration",description:"Remote Configuration is a feature of the mobile native trackers that allows for the configuration of the tracker without distributing an app update. In fact, the configuration of the tracker lies on the app bundle submitted to the stores for the distribution. Each tracker configuration change would require the resubmission of the whole app bundle.",source:"@site/docs/collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration/index.md",sourceDirName:"collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration",slug:"/collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration/",permalink:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration/",draft:!1,editUrl:"https://github.com/snowplow/snowplow.github.io/tree/main/docs/collecting-data/collecting-from-own-applications/mobile-trackers/remote-configuration/index.md",tags:[],version:"current",lastUpdatedAt:1662725915,formattedLastUpdatedAt:"Sep 9, 2022",sidebarPosition:50,frontMatter:{title:"Set up the remote configuration",date:"2022-08-30",sidebar_position:50},sidebar:"defaultSidebar",previous:{title:"Configuring how events are sent",permalink:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/configuring-how-events-are-sent/"},next:{title:"Anonymous Tracking",permalink:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/anonymous-tracking/"}},u={},d=[{value:"The remote configuration file",id:"the-remote-configuration-file",level:2},{value:"Refresh the configuration",id:"refresh-the-configuration",level:2},{value:"Policy for runtime settings and remote configuration updates",id:"policy-for-runtime-settings-and-remote-configuration-updates",level:2}],p={toc:d};function f(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"set-up-the-remote-configuration"},"Set up the remote configuration"),(0,o.kt)("p",null,"Remote Configuration is a feature of the mobile native trackers that allows for the configuration of the tracker without distributing an app update. In fact, the configuration of the tracker lies on the app bundle submitted to the stores for the distribution. Each tracker configuration change would require the resubmission of the whole app bundle."),(0,o.kt)("p",null,"With remote configuration, the developer just indicates to the tracker how to download the configuration file. The tracker will automatically reconfigure itself based on the downloaded file."),(0,o.kt)("p",null,"Once the tracker SDK is correctly set as a dependency in your app project you have to instrument the tracker for the remote configuration:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In your application delegate ",(0,o.kt)("inlineCode",{parentName:"p"},"AppDelegate.swift")," add ",(0,o.kt)("inlineCode",{parentName:"p"},"import SnowplowTracker"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"application(_:didFinishLaunchingWithOptions:)")," method, set up the SDK as follows:"))),(0,o.kt)(i.Z,{groupId:"platform",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'// Indicate the URL where to download the config file\nlet remoteConfig = RemoteConfiguration(endpoint: REMOTE_CONFIG_URL, method: .get)\n\n// Default configuration used in case the remote config is not accessible\nlet defaultNetworkConfig = NetworkConfiguration(endpoint: DEFAULT_COLLECTOR_URL, method: .post);\nlet defaultConfig = [ConfigurationBundle(namespace: "defaultNamespace", networkConfiguration: networkConfig)]\n\n// Callback for when the tracker reconfigures itself passing a list of active namespaces and the state of the configuration describing where it was fetched from\nlet successCallback: ([String]?) -> Void = { namespaces, state in\n  // This callback can be used for last minute, post-configuration, updates once the tracker instance is enabled and configured.\n}\n\n// Setup tracker with remote configuration\nSnowplow.setup(remoteConfiguration: remoteConfig, defaultConfiguration: defaultConfig, onSuccess: successCallback)\n'))),(0,o.kt)(r.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// Indicate the URL where to download the config file\nRemoteConfiguration remoteConfig = new RemoteConfiguration(REMOTE_CONFIG_URL, HttpMethod.get);\n\n// Default configuration used in case the remote config is not accessible\nNetworkConfiguration defaultNetworkConfig = new NetworkConfiguration(DEFAULT_COLLECTOR_URL, HttpMethod.post);\nList<ConfigurationBundle> defaultConfig = Lists.listOf(new ConfigurationBundle("defaultNamespace", networkConfig));\n\n// Setup tracker with remote configuration\nSnowplow.setup(context, remoteConfig, defaultConfig, configurationPair -> {\n  List<String> namespaces = configurationPair.first;\n  ConfigurationState configurationState = configurationPair.second; // either cached, default or fetched from the remote endpoint\n\n  // This callback can be used for last minute, post-configuration, updates once the tracker instance is enabled and configured.\n});\n')))),(0,o.kt)("p",null,"Once the app starts, the Snowplow tracker initializer will attempt to download the remote configuration file. Meanwhile, it will initialize the tracker instance (or multiple tracker instances) based on the last cached configuration. The cached configuration is the last configuration downloaded remotely. If it's not available, the tracker initializer will spin up the default configuration passed as a parameter. Every time the initializer successfully initializes the tracker instances it calls a callback passing the list of activated namespaces and the state of the configuration which represents the source where the configuration was retrieved from (using default values, cache, or fetched from the remote endpoint). The callback can be used for last minute settings at runtime once the tracker has been instanced."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultConfiguration")," parameter takes a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"ConfigurationBundle")," objects. Each one represents a tracker instance and it's own configuration. Each tracker instance is identified by a ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace")," which is a parameter required in each ",(0,o.kt)("inlineCode",{parentName:"p"},"ConfigurationBundle"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"onSuccess")," callback is called for each successful configuration. For example, if the tracker has a cached configuration and it's downloading a new configuration, first the ",(0,o.kt)("inlineCode",{parentName:"p"},"onSuccess")," callback will be called for the cached configuration and then it will be called when the downloaded configuration is applied. When it happens the cached configuration is substituted with the downloaded one."),(0,o.kt)("h2",{id:"the-remote-configuration-file"},"The remote configuration file"),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"RemoteConfiguration")," object passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"setup")," method is specified the REMOTE_CONFIG_URL, which is the url where the developer hosts the configuration file.\nThere aren't restrictions about where to host the file but possible solutions may be S3 with Cloudfront or a Google Cloud Storage bucket."),(0,o.kt)("p",null,"The configuration file is simply a JSON file compliant with the ",(0,o.kt)("a",{parentName:"p",href:"http://iglucentral.com/schemas/com.snowplowanalytics.mobile/remote_config/jsonschema/1-0-0"},"Remote Config JSONSchema"),"."),(0,o.kt)("p",null,"An example of remote config specification:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$schema": "http://iglucentral.com/schemas/com.snowplowanalytics.mobile/remote_config/jsonschema/1-0-0",\n  "configurationVersion": 1,\n  "configurationBundle": [\n    {\n      "namespace": "testTracker1",\n      "networkConfiguration": {\n        "endpoint": "http://<collector.url>",\n        "method": "get"\n      },\n      "trackerConfiguration": {\n        "appId": "app-identifier",\n        "devicePlatform": "mob",\n        "logLevel": "off",\n        "sessionContext": false,\n        "applicationContext": false,\n        "platformContext": false,\n        "geoLocationContext": false,\n        "screenContext": false,\n        "screenViewAutotracking": false,\n        "lifecycleAutotracking": false,\n        "installAutotracking": false,\n        "exceptionAutotracking": false,\n        "diagnosticAutotracking": false\n      },\n      "subjectConfiguration": {\n        "userId": "example",\n        "networkUserId": "example",\n        "domainUserId": "example",\n        "useragent": "example",\n        "ipAddress": "example",\n        "timezone": "example",\n        "language": "example"\n      },\n      "sessionConfiguration": {\n        "backgroundTimeout": 1800,\n        "foregroundTimeout": 1800\n      }\n    }\n  ]\n}\n')),(0,o.kt)("p",null,"The required fields are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"$schema"),": It specifies the format of the configuration file and it's used by the tracker to check if the format is compatible with that version of the tracker."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"configurationVersion"),": It's an incremental version number that identifies the current configuration. ",(0,o.kt)("strong",{parentName:"li"},"It MUST be increased on each update.")," The tracker compares this value with the configurationVersion of the cached configuration to decide whether to update or not the tracker configuration."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"configurationBundle"),": This is a list of configurations for the various tracker instances the developer wants to activate in the app. Usually there is a unique tracker instance for the app so the configurationBundle will likely be an array of a single object like in the example above.")),(0,o.kt)("p",null,"The elements of the ",(0,o.kt)("inlineCode",{parentName:"p"},"configurationBundle"),' list are just a subset of the common configuration settings described in the "Introduction" section.\nAt the moment the configuration objects configurable remotely are:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"networkConfiguration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"trackerConfiguration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"subjectConfiguration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sessionConfiguration"))),(0,o.kt)("p",null,"Note: The ",(0,o.kt)("inlineCode",{parentName:"p"},"networkConfiguration")," is fundamental in order to set the collector endpoint, the URL where the tracked events will be sent. If the ConfigurationBundle has a ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace")," but not the ",(0,o.kt)("inlineCode",{parentName:"p"},"networkConfiguration"),", the tracker initializer will remove the tracker instance with the corresponding namespace."),(0,o.kt)("h2",{id:"refresh-the-configuration"},"Refresh the configuration"),(0,o.kt)("p",null,"As shown above the developer can enforce the download of the configuration file at the start up of the app.\nIf the developer wants to check for configuration updates more often, for example at runtime or when the app comes back from background state, it's possible to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"refresh")," method, placing it where the developer wants to perform the download and the configuration check."),(0,o.kt)(i.Z,{groupId:"platform",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},"let successCallback: ([String]?) -> Void = { namespaces, state in\n    // This callback can be used for last minute, post-configuration, updates once the tracker instance is enabled and configured.\n}\n\nSnowplow.refresh(onSuccess: successCallback)\n"))),(0,o.kt)(r.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Snowplow.refresh(context, configurationPair -> {\n  List<String> namespaces = configurationPair.first;\n  ConfigurationState configurationState = configurationPair.second;\n\n  // This callback can be used for last minute, post-configuration, updates once the tracker instance is enabled and configured.\n});\n")))),(0,o.kt)("p",null,"The method needs only the callback parameter, without any remote configuration url or default configuration, because this is intended just for the configuration updates, not for the initial setup.\nThe tracker will be configured only if a new configuration (with a higher ",(0,o.kt)("inlineCode",{parentName:"p"},"configurationVersion")," value) is available at the url indicated in the ",(0,o.kt)("inlineCode",{parentName:"p"},"RemoteConfiguration")," passed earlier at start up of the app in the ",(0,o.kt)("inlineCode",{parentName:"p"},"setup")," method call."),(0,o.kt)("h2",{id:"policy-for-runtime-settings-and-remote-configuration-updates"},"Policy for runtime settings and remote configuration updates"),(0,o.kt)("p",null,"When the tracker initializer updates the tracker configuration, it would reset all the previous configuration with the new settings. Obviously, this can cause issues in case some runtime configuration has been applied meanwhile. To avoid this the tracker keeps track of runtime changes in the configuration settings and when a new remote configuration is downloaded and applied, it doesn't override the settings already changed at runtime."),(0,o.kt)("p",null,"A clear example is a runtime change on ",(0,o.kt)("inlineCode",{parentName:"p"},"userId")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"SubjectController"),":"),(0,o.kt)(i.Z,{groupId:"platform",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-swift"},'// Load configuration with userId = nil\nSnowplow.setup(remoteConfiguration: remoteConfig, defaultConfiguration: defaultConfig, onSuccess: successCallback)\n\n/* userId is set to nil */\n\n...later...\n\ntracker.subject.userId = "my-runtime-updated-userId"\n\n/* userId is is set to "my-runtime-updated-userId" */\n\n...later...\n\n// Later refreshing the configuration with userId = nil\nSnowplow.refresh(onSuccess: successCallback)\n\n/* userId is still set to "my-runtime-updated-userId" because it was set at runtime */\n'))),(0,o.kt)(r.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'// Load configuration with userId = nil\nSnowplow.setup(context, remoteConfig, defaultConfig, successCallback);\n\n/* userId is set to nil */\n\n...later...\n\ntracker.getSubject().userId = "my-runtime-updated-userId"\n\n/* userId is is set to "my-runtime-updated-userId" */\n\n...later...\n\n// Later refreshing the configuration with userId = nil\nSnowplow.refresh(context, successCallback)\n\n/* userId is still set to "my-runtime-updated-userId" because it was set at runtime */\n')))))}f.isMDXComponent=!0}}]);