"use strict";(self.webpackChunkdocsite_poc_github_io=self.webpackChunkdocsite_poc_github_io||[]).push([[18715],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=i,k=u["".concat(s,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(k,o(o({ref:t},p),{},{components:n})):a.createElement(k,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),i=n(86010);const r="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,o),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(87462),i=n(67294),r=n(86010),o=n(72389),l=n(67392),s=n(7094),c=n(12466);const p="tabList__CuJ",d="tabItem_LNqP";function u(e){var t,n;const{lazy:o,block:u,defaultValue:m,values:k,groupId:g,className:h}=e,f=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=k?k:f.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),w=(0,l.l)(v,((e,t)=>e.value===t.value));if(w.length>0)throw new Error('Docusaurus error: Duplicate values "'+w.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const b=null===m?m:null!=(t=null!=m?m:null==(n=f.find((e=>e.props.default)))?void 0:n.props.value)?t:f[0].props.value;if(null!==b&&!v.some((e=>e.value===b)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+v.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:y,setTabGroupChoices:T}=(0,s.U)(),[N,C]=(0,i.useState)(b),x=[],{blockElementScrollPositionUntilNextRender:S}=(0,c.o5)();if(null!=g){const e=y[g];null!=e&&e!==N&&v.some((t=>t.value===e))&&C(e)}const _=e=>{const t=e.currentTarget,n=x.indexOf(t),a=v[n].value;a!==N&&(S(t),C(a),null!=g&&T(g,String(a)))},I=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=x.indexOf(e.currentTarget)+1;n=null!=(a=x[t])?a:x[0];break}case"ArrowLeft":{var i;const t=x.indexOf(e.currentTarget)-1;n=null!=(i=x[t])?i:x[x.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":u},h)},v.map((e=>{let{value:t,label:n,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:e=>x.push(e),onKeyDown:I,onFocus:_,onClick:_},o,{className:(0,r.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":N===t})}),null!=n?n:t)}))),o?(0,i.cloneElement)(f.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==N})))))}function m(e){const t=(0,o.Z)();return i.createElement(u,(0,a.Z)({key:String(t)},e))}},36504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),r=n(65488),o=n(85162);const l={title:"Tracking events",date:"2022-08-30",sidebar_position:10},s="Tracking events",c={unversionedId:"collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events/index",id:"collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events/index",title:"Tracking events",description:"To track an event, pass an event to the tracker instance.",source:"@site/docs/collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events/index.md",sourceDirName:"collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events",slug:"/collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events/",permalink:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events/",draft:!1,editUrl:"https://github.com/snowplow/snowplow.github.io/tree/main/docs/collecting-data/collecting-from-own-applications/mobile-trackers/tracking-events/index.md",tags:[],version:"current",lastUpdatedAt:1662725915,formattedLastUpdatedAt:"Sep 9, 2022",sidebarPosition:10,frontMatter:{title:"Tracking events",date:"2022-08-30",sidebar_position:10},sidebar:"defaultSidebar",previous:{title:"Installation and set-up",permalink:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/installation-and-set-up/"},next:{title:"Custom tracking using schemas",permalink:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/custom-tracking-using-schemas/"}},p={},d=[{value:"Auto-tracked events and entities",id:"auto-tracked-events-and-entities",level:2},{value:"Platform and Application Data Tracking",id:"platform",level:3},{value:"App Lifecycle Tracking",id:"lifecycle-tracking",level:3},{value:"Session Tracking",id:"session",level:3},{value:"Session callback",id:"session-callback",level:4},{value:"Screen View Tracking",id:"screen-view-tracking",level:3},{value:"Exception Tracking",id:"exception-tracking",level:3},{value:"Installation Tracking",id:"installation-tracking",level:3},{value:"Manually-tracked events",id:"manually-tracked-events",level:2},{value:"Creating a Structured event",id:"creating-a-structured-event",level:3},{value:"Creating a Timing event",id:"creating-a-timing-event",level:3},{value:"Creating a ScreenView event",id:"creating-a-screenview-event",level:3},{value:"Creating a Consent event",id:"creating-a-consent-event",level:3},{value:"Consent Granted",id:"consent-granted",level:4},{value:"Consent Withdrawn",id:"consent-withdrawn",level:4},{value:"Tracking Ecommerce Transactions",id:"tracking-ecommerce-transactions",level:3},{value:"Tracking Push and Local Notifications",id:"tracking-push-and-local-notifications",level:3},{value:"Tracking Deep Links",id:"tracking-deep-links",level:3},{value:"Tracking data that is not event-type specific",id:"tracking-data-that-is-not-event-type-specific",level:2},{value:"Adding custom timestamps to events",id:"adding-custom-timestamps-to-events",level:3}],u={toc:d};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tracking-events"},"Tracking events"),(0,i.kt)("p",null,"To track an event, pass an event to the tracker instance. "),(0,i.kt)("p",null,"For example, tracking a ScreenView:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = ScreenView(name: "screen name", screenId: nil)\nlet eventId = tracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'ScreenView event = new ScreenView("screen", UUID.randomUUID().toString());         \ntracker.track(event);\n')))),(0,i.kt)("p",null,"The tracker makes it easy to track different kinds of data. We provide a range of ",(0,i.kt)("inlineCode",{parentName:"p"},"Event")," classes for tracking out-of-the-box event types as well as fully custom events. "),(0,i.kt)("p",null,"Each event can bring context which is composed by entities. The tracker attaches entities to the events based on the configuration, but you can attach your own custom entities as well."),(0,i.kt)("p",null,"Every tracked event payload has a unique ",(0,i.kt)("inlineCode",{parentName:"p"},"event_id")," UUID string set by the tracker and a set of timestamps along with other ubiquitous properties such as the ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"event_id")," is returned from the ",(0,i.kt)("inlineCode",{parentName:"p"},"tracker.track(event)")," method. You can know more about how events and entities are structured ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/docs/collecting-data/collecting-from-own-applications/snowplow-tracker-protocol"},"here"),"."),(0,i.kt)("h2",{id:"auto-tracked-events-and-entities"},"Auto-tracked events and entities"),(0,i.kt)("p",null,"Automatically captured data are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Platform and Application Context Tracking"),": Captures contextual information about the device and the app."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Session Tracking"),": Captures the session which helps to keep track of the user activity in the app."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"App Lifecycle Tracking"),": Captures application lifecycle state changes (foreground/background transitions)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Screen View Tracking"),": Captures each time a new \u201cscreen\u201d is loaded."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Exception Tracking"),": Captures any unhandled exceptions within the application."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Installation Tracking"),": Captures an install event which occurs the first time an application is opened.")),(0,i.kt)("p",null,"Autotracking can be enabled in the tracker configuration. In this example, some helpful automatic entities and all autotracking is enabled:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let trackerConfig = TrackerConfiguration()\n    .platformContext(true)\n    .applicationContext(true)\n    .lifecycleAutotracking(true)\n    .sessionContext(true)\n    .screenViewAutotracking(true)\n    .screenContext(true)\n    .exceptionAutotracking(true)\n    .installAutotracking(true)\n\nSnowplow.createTracker(\n    namespace: "appTracker",\n    network: networkConfig,\n    configurations: [trackerConfig]\n)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .platformContext(true)\n    .applicationContext(true)\n    .lifecycleAutotracking(true)\n    .sessionContext(true)\n    .screenViewAutotracking(true)\n    .screenContext(true)\n    .exceptionAutotracking(true)\n    .installAutotracking(true);\n\nSnowplow.createTracker(getApplicationContext(),\n                namespace,\n                networkConfiguration,\n                trackerConfig);\n")))),(0,i.kt)("p",null,"You can know more about the ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," properties ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1configuration_1_1_tracker_configuration.html"},"here"),"."),(0,i.kt)("h3",{id:"platform"},"Platform and Application Data Tracking"),(0,i.kt)("p",null,"They capture information about the device and the app."),(0,i.kt)("p",null,"They are enabled by default. But the setting can be changed through ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," like in the example below:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    .platformContext(true)\n    .applicationContext(true)\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .platformContext(true)\n    .applicationContext(true);\n")))),(0,i.kt)("p",null,"More details on ",(0,i.kt)("a",{parentName:"p",href:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/client-side-properties/"},"Subject")),(0,i.kt)("h3",{id:"lifecycle-tracking"},"App Lifecycle Tracking"),(0,i.kt)("p",null,"It captures application lifecycle state changes. In particular, when the app changes the state from foreground to background and viceversa."),(0,i.kt)("p",null,"The lifecycle tracking is disabled by default. It can be enabled in ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," like in the example below:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    .lifecycleAutotracking(true)\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .lifecycleAutotracking(true);\n")))),(0,i.kt)("p",null,"Once enabled, the tracker will automatically track a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_background.html"},(0,i.kt)("inlineCode",{parentName:"a"},"Background")," event")," when the app is moved to background and a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_foreground.html"},(0,i.kt)("inlineCode",{parentName:"a"},"Foreground")," event")," when the app moves back to foreground (becomes visible in the screen)."),(0,i.kt)("p",null,"The tracker attaches a ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1entity_1_1_lifecycle_entity.html"},(0,i.kt)("inlineCode",{parentName:"a"},"LifecycleEntity"))," to all the events tracked by the tracker reporting if the app was visible (foreground state) when the event was tracked."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"LifecycleEntity")," value is conditioned by the internal state of the tracker only. To make an example, if the app is in foreground state but the developer tracks a ",(0,i.kt)("inlineCode",{parentName:"p"},"Background")," event intentionally, it would force the generation of a ",(0,i.kt)("inlineCode",{parentName:"p"},"LifecycleEntity")," that mark the app as non visible, even if it's actually visible in the device."),(0,i.kt)("h3",{id:"session"},"Session Tracking"),(0,i.kt)("p",null,"Captures the session which helps to keep track of the user activity in the app."),(0,i.kt)("p",null,"Client session tracking is enabled by default. It can be set through the ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," as explained below."),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    .sessionContext(true)\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .sessionContext(true);\n")))),(0,i.kt)("p",null,"When enabled, the tracker appends a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/snowplow/iglu-central/blob/master/schemas/com.snowplowanalytics.snowplow/client_session/jsonschema/1-0-2"},(0,i.kt)("inlineCode",{parentName:"a"},"client_session")," entity")," to each event it sends and it maintains this session information as long as the application is installed on the device."),(0,i.kt)("p",null,"Sessions correspond to tracked user activity. A session expires when no tracking events have occurred for the amount of time defined in a timeout (by default 30 minutes). The session timeout check is executed for each event tracked. If the gap between two consecutive events is longer than the timeout the session is renewed. There are two timeouts since a session can timeout in the foreground (while the app is visible) or in the background (when the app has been suspended, but not closed)."),(0,i.kt)("p",null,"The timeouts for the session can be configured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"SessionConfiguration")," like in the example below:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let sessionConfig = SessionConfiguration(\n    foregroundTimeout: Measurement(value: 360, unit: .seconds),\n    backgroundTimeout: Measurement(value: 360, unit: .seconds)\n)\nSnowplow.createTracker(\n    namespace: "appTracker",\n    network: networkConfig,\n    configurations: [trackerConfig, sessionConfig]\n)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"SessionConfiguration sessionConfig = new SessionConfiguration(\n    new TimeMeasure(6, TimeUnit.SECONDS),\n    new TimeMeasure(30, TimeUnit.SECONDS)\n);\nSnowplow.createTracker(getApplicationContext(), namespace, networkConfig, sessionConfig);\n")))),(0,i.kt)("p",null,"The lifecycle events (",(0,i.kt)("inlineCode",{parentName:"p"},"Foreground")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Background")," events) have a role in the session expiration. The lifecycle events can be enabled as explained in ",(0,i.kt)("a",{parentName:"p",href:"#lifecycle-tracking"},"App Lifecycle Tracking"),". Once enabled they will be fired automatically when the app moves from foreground state to background state and vice versa."),(0,i.kt)("p",null,"When the app moves from foreground to background, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Background")," event is fired. If session tracking is enabled, the session entity will be attached to the event checking the session expiration using the foreground timeout.\nWhen the app moves from background to foreground, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foreground")," event is fired. If session tracking is enabled, the session entity will be attached to the event checking the session expiration using the background timeout."),(0,i.kt)("p",null,"For instance, with this configuration:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"SessionConfiguration(\n    foregroundTimeout: Measurement(value: 360, unit: .seconds),\n    backgroundTimeout: Measurement(value: 15, unit: .seconds)\n)       \n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"SessionConfiguration sessionConfig = new SessionConfiguration(\n    new TimeMeasure(360, TimeUnit.SECONDS),\n    new TimeMeasure(15, TimeUnit.SECONDS)\n);\n")))),(0,i.kt)("p",null,"the session would expire if the app is in background for more than 15 seconds, like in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"time: 0s - ScreenView event - foreground timeout session check - session 1\ntime: 3s - Background event - foreground timeout session check (3 < 360) - session 1\ntime: 30s - Foreground event - background timeout session check (30 > 15) - session 2\n")),(0,i.kt)("p",null,"In the above example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Foreground")," event triggers a new session because the time spent in background (without tracked events) is bigger than the background timeout for the session."),(0,i.kt)("h4",{id:"session-callback"},"Session callback"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This feature is available since v3.1.")),(0,i.kt)("p",null,"The tracker allows the configuration of a callback to inform the app every time a new session is created (in correspondence of a session timeout check).\nThis can be configured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"SessionConfiguration")," and it provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"SessionState")," where all the info already tracked in the session can be accessed."),(0,i.kt)("p",null,"Below is an example of where the session callback is used to print out the values of session every time a new session is generated by the tracker:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'...\nlet sessionConfig = SessionConfiguration()\n    .onSessionStateUpdate { session in\n        print("SessionState: id: \\(session.sessionId) - index: \\(session.sessionIndex) - userID: \\(session.userId) - firstEventID: \\(session.firstEventId)")\n    }\n...\nlet tracker = Snowplow.createTracker(namespace: kNamespace, network: networkConfig, configurations: [sessionConfig])\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'...\nSessionConfiguration sessionConfig = new SessionConfiguration(\n    new TimeMeasure(6, TimeUnit.SECONDS),\n    new TimeMeasure(30, TimeUnit.SECONDS)\n)\n    .onSessionUpdate(state -> log(\n        "Session: " + state.getSessionId()\n                + "\\r\\nprevious: " + state.getPreviousSessionId()\n                + "\\r\\neventId: " + state.getFirstEventId()\n                + "\\r\\nindex: " + state.getSessionIndex()\n                + "\\r\\nuserId: " + state.getUserId()\n    ));\n\n...\nSnowplow.createTracker(getApplicationContext(), namespace, networkConfig, sessionConfig);\n')))),(0,i.kt)("h3",{id:"screen-view-tracking"},"Screen View Tracking"),(0,i.kt)("p",null,"It captures screen changes within the app."),(0,i.kt)("p",null,"The screen view tracking is enabled by default. It can be set in ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," like in the example below:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    .screenViewAutotracking(true)\n    .screenContext(true)\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .screenViewAutotracking(true)\n    .screenContext(true);\n")))),(0,i.kt)("p",null,"The configuration is composed by two settings:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"screenViewAutotracking"),": the tracker automatically tracks each screen change (triggered by ",(0,i.kt)("inlineCode",{parentName:"li"},"viewDidAppear")," in a ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewController"),") using a ",(0,i.kt)("a",{parentName:"li",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_screen_view.html"},(0,i.kt)("inlineCode",{parentName:"a"},"ScreenView")," event"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"screenContext"),": the tracker attaches a ",(0,i.kt)("a",{parentName:"li",href:"http://iglucentral.com/schemas/com.snowplowanalytics.mobile/screen/jsonschema/1-0-0"},(0,i.kt)("inlineCode",{parentName:"a"},"Screen")," entity")," to all the events tracked by the tracker reporting the last (and probably current) screen visible on device when the event was tracked.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Screen")," entity is conditioned by the internal state of the tracker only. To make an example, if the developer manually tracks a ",(0,i.kt)("inlineCode",{parentName:"p"},"ScreenView")," event, all the following events will have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Screen")," entity attached reporting the same information as the last tracked ScreenView event, even if it was manually tracked and the app is in a different screen."),(0,i.kt)("p",null,"Indeed, disabling the ",(0,i.kt)("inlineCode",{parentName:"p"},"screenViewAutotracking")," only, the tracker can still attach ",(0,i.kt)("inlineCode",{parentName:"p"},"Screen")," entities automatically based only to the manual tracking of ",(0,i.kt)("inlineCode",{parentName:"p"},"ScreenView")," events, and vice versa."),(0,i.kt)("h3",{id:"exception-tracking"},"Exception Tracking"),(0,i.kt)("p",null,"It captures any unhandled exceptions within the application."),(0,i.kt)("p",null,"The exception tracking is enabled by default. It can be set in ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," like in the example below:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    .exceptionAutotracking(true)\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .exceptionAutotracking(true);\n")))),(0,i.kt)("p",null,"It allows the tracker to intercept critical exceptions in the app. Exceptions can crash the app so it's likely that the event will be sent after the restart of the app. Being a critical situation we can't be 100% sure that all the exception stacktraces are reliably stored for sending before the crash of the app."),(0,i.kt)("h3",{id:"installation-tracking"},"Installation Tracking"),(0,i.kt)("p",null,"It tracks an install event which occurs the first time an application is opened. The tracker will record when it's first been installed, so deleting and reinstalling an app will trigger another install event."),(0,i.kt)("p",null,"If installation autotracking is not enabled, the tracker will still keep track of when the app was first installed, so that when enabled, the tracker will send the recorded install event with a timestamp reflecting when it was first installed."),(0,i.kt)("p",null,"The installation autotracking is enabled by default. It can be set in ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration")," like in the example below:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    .installAutotracking(true)\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    .installAutotracking(true);\n")))),(0,i.kt)("h2",{id:"manually-tracked-events"},"Manually-tracked events"),(0,i.kt)("p",null,"The tracker provides classes for tracking different types of events.\nThe events are divided in two groups: canonical events and self-describing events."),(0,i.kt)("h3",{id:"creating-a-structured-event"},"Creating a Structured event"),(0,i.kt)("p",null,"Our philosophy in creating Snowplow is that users should capture important consumer interactions and design suitable data structures for this data capture. You can read more about that philosophy ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/docs/understanding-tracking-design/"},"here"),". Using ",(0,i.kt)("inlineCode",{parentName:"p"},"trackSelfDescribingEvent")," captures these interactions with custom schemas, as described above."),(0,i.kt)("p",null,"However, as part of a Snowplow implementation there may be interactions where custom Self Describing events are perhaps too complex or unwarranted. They are then candidates to track using ",(0,i.kt)("inlineCode",{parentName:"p"},"Structured"),", if none of the other event-specific methods outlined below are appropriate."),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = Structured(category: "Example", action: "my-action")\n    .label("my-label")\n    .property("my-property")\n    .value(5)\n\ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'Structured event = new Structured("category", "action")\n    .label("label")\n    .property("property")\n    .value(5);\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_structured.html"},"list of options"),"."),(0,i.kt)("h3",{id:"creating-a-timing-event"},"Creating a Timing event"),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Timing")," events to track user timing events such as how long resources take to load."),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = Timing(category: "timing-category", variable: "timing-variable", timing: 5)\n    .label("optional-label")       \n\ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'Timing event = new Timing("timing-category", "timing-variable", 5)\n    .label("optional-label");\n\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_timing.html"},"list of options"),"."),(0,i.kt)("h3",{id:"creating-a-screenview-event"},"Creating a ScreenView event"),(0,i.kt)("p",null,"Track the user viewing a screen within the application. This type of tracking is typically used when automatic screen view tracking is not suitable within your application."),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = ScreenView(name: "DemoScreenName", screenId: UUID())\n\ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'ScreenView event = new ScreenView("DemoScreenName", UUID.randomUUID());\n\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_screen_view.html"},"list of options"),"."),(0,i.kt)("h3",{id:"creating-a-consent-event"},"Creating a Consent event"),(0,i.kt)("h4",{id:"consent-granted"},"Consent Granted"),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConsentGranted")," event to track a user opting into data collection. A consent document context will be attached to the event using the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," arguments supplied."),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = ConsentGranted(expiry: "2022-01-01T00:00:00Z", documentId: "1234abcd", version: "1.2")       \n    .name("document-name")\n    .documentDescription("document-description")\n                \ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'ConsentGranted event = new ConsentGranted("2022-01-01T00:00:00Z", "1234abcd", "1.2")\n        .documentDescription("document-description")\n        .documentName("document-name");\n\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_consent_granted.html"},"list of options"),"."),(0,i.kt)("h4",{id:"consent-withdrawn"},"Consent Withdrawn"),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConsentWithdrawn")," event to track a user withdrawing consent for data collection. A consent document context will be attached to the event using the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," arguments supplied. To specify that a user opts out of all data collection, ",(0,i.kt)("inlineCode",{parentName:"p"},"all")," should be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = ConsentWithdrawn()\n    .all(true)\n    .documentId("1234abcd")\n    .version("1.2")       \n    .name("document-name")\n    .documentDescription("document-description")\n                \ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'ConsentWithdrawn event = new ConsentWithdrawn(false, "1234abcd", "1.2")\n        .documentDescription("document-description")\n        .documentName("document-name");\n\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_consent_withdrawn.html"},"list of options"),"."),(0,i.kt)("h3",{id:"tracking-ecommerce-transactions"},"Tracking Ecommerce Transactions"),(0,i.kt)("p",null,"Modelled on Google Analytics ecommerce tracking capability, Snowplow uses three steps that can be used together to track online transactions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Create a Ecommerce event.")," Use ",(0,i.kt)("inlineCode",{parentName:"p"},"Ecommerce")," to initialize a transaction object. This will be the object that is loaded with all the data relevant to the specific transaction that is being tracked including all the items in the order, the prices of the items, the price of shipping and the ",(0,i.kt)("inlineCode",{parentName:"p"},"order_id"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Add items to the transaction.")," Create an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"EcommerceItem")," to pass to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ecommerce")," object.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Submit the transaction to Snowplow")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"track()")," method, once all the relevant data has been loaded into the object."))),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let transactionID = "6a8078be"       \n                \nlet itemArray = [       \n  EcommerceItem(sku: "DemoItemSku", price: 0.75, quantity: 1)\n    .name("DemoItemName")       \n    .category("DemoItemCategory")       \n    .currency("USD")       \n]       \n\nlet event = Ecommerce(orderId: transactionID, totalValue: 350, items: itemArray)\n    .affiliation("DemoTransactionAffiliation")\n    .taxValue(10)\n    .shipping(15)\n    .city("Boston")\n    .state("Massachusetts")\n    .country("USA")\n    .currency("USD")\n\ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'EcommerceTransactionItem item = new EcommerceTransactionItem("sku-1", 0.75, 1)\n    .name("DemoItemName")\n    .category("DemoItemCategory")\n    .currency("USD")\n    .orderId("item-1");\n\nList<EcommerceTransactionItem> items = new LinkedList<>();\nitems.add(item);\n\nEcommerceTransaction event = new EcommerceTransaction("order-1", 350, items)\n    .affiliation("DemoTransactionAffiliation")\n    .taxValue(10)\n    .shipping(15)\n    .city("Boston")\n    .state("Massachusetts")\n    .country("USA")\n    .currency("USD");\n\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_ecommerce_transaction.html"},"list of options"),"."),(0,i.kt)("h3",{id:"tracking-push-and-local-notifications"},"Tracking Push and Local Notifications"),(0,i.kt)("p",null,"To track an event when a push (or local) notification is used, it is possible to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"MessageNotification")," event:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'let event = MessageNotification(title: "title", body: "body", trigger: .push)\n    .notificationTimestamp("2020-12-31T15:59:60-08:00")\n    .action("action")\n    .bodyLocKey("loc key")\n    .bodyLocArgs(["loc arg1", "loc arg2"])\n    .sound("chime.mp3")\n    .notificationCount(9)\n    .category("category1")\n    .attachments([\n        MessageNotificationAttachment(identifier: "id", type: "type", url: "https://snowplow.io")\n    ]);\ntracker.track(event)\n'))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'MessageNotification event = new MessageNotification("title", "body", MessageNotificationTrigger.push)\n        .notificationTimestamp("2021-10-18T10:16:08.008Z")\n        .category("category")\n        .action("action")\n        .bodyLocKey("loc key")\n        .bodyLocArgs(Arrays.asList("loc arg1", "loc arg2"))\n        .sound("chime.mp3")\n        .notificationCount(9)\n        .category("category1");\ntracker.track(event);\n')))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_message_notification.html"},"list of options"),"."),(0,i.kt)("h3",{id:"tracking-deep-links"},"Tracking Deep Links"),(0,i.kt)("p",null,"The Deep Link is received by the mobile operating system and passed to the related app. Our mobile tracker can't automatically track the Deep Link, but we provide an out-of-the-box event that can be used by the developer to manually track it as soon as the Deep Link is received in the app."),(0,i.kt)("p",null,"It will be the duty of the tracker to automatically attach the information of the Deep Link to the first ScreenView tracked."),(0,i.kt)("p",null,"In practice, when the app receives a Deep Link, the developer can track it through the DeepLinkReceived event:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"public func application(_ application: UIApplication,\n                        continue userActivity: NSUserActivity,\n                        restorationHandler: @escaping ([Any]?) -> Void) -> Bool\n{\n    ...\n    if let url = userActivity.webpageURL {\n        let deepLinkEvent = DeepLinkReceived(url: userActivity.webpageURL.absoluteString)\n            .referrer(userActivity.referrerURL.absoluteString)\n        tracker.track(deepLinkEvent)\n    }\n    ...\n}\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@Override\npublic void onCreate(Bundle savedInstanceState) {\n    ...\n\n    // Extract info from Intent\n    Intent intent = getIntent();\n    String deepLinkUrl = intent.getData().toString();\n    String referrer = null;\n    Bundle extras = intent.getExtras();\n    if (extras != null) {\n        Uri referrerUri = extras.get(Intent.EXTRA_REFERRER);\n        if (referrerUri != null) {\n            referrer = referrerUri.toString();\n        }\n    }\n    // Create and track the event\n    DeepLinkReceived event = new DeepLinkReceived(deepLinkUrl).referrer(referrer);\n    tracker.track(event);\n\n    ...\n}\n")))),(0,i.kt)("p",null,"See the API docs for the full ",(0,i.kt)("a",{parentName:"p",href:"https://docs.snowplow.io/snowplow-android-tracker/classcom_1_1snowplowanalytics_1_1snowplow_1_1event_1_1_deep_link_received.html"},"list of options"),"."),(0,i.kt)("p",null,"The tracker keeps memory of the tracked Deep Link event and will attach a Deep Link entity to the first ScreenView tracked in the tracker.\nThis is helpful during the analysis of the data because it will be clear the relation between the content visualized by the user (ScreenView event) and source (DeepLink entity) that originated that visualisation."),(0,i.kt)("p",null,"This behaviour is enabled by default but it can be disabled from the ",(0,i.kt)("inlineCode",{parentName:"p"},"TrackerConfiguration"),"."),(0,i.kt)("p",null,"For example:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"let trackerConfig = TrackerConfiguration()\n    ...\n    .deepLinkContext(false)\n    ...\n"))),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"TrackerConfiguration trackerConfig = new TrackerConfiguration()\n    ...\n    .deepLinkContext(false);\n")))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DeepLinkReceived")," event can be used in pair with a ",(0,i.kt)("inlineCode",{parentName:"p"},"campaign-attribution-enrichment")," appropriately enabled in the Snowplow pipeline.\nIt works exactly like for ",(0,i.kt)("inlineCode",{parentName:"p"},"PageView")," events in the web/JS tracker.\nWhen the user taps on an advertising banner or a marketing email or message, it can trigger the launch of the app through the Deep Linking feature. The referral from the advertising campaigns, websites, or other source can be composed by UTM parameters used to attribute the user activity back to the campaign.\nThe Campaign Attribution Enrichment can parse the DeepLinkReceived event extracting the UTM parameters in the deep link url."),(0,i.kt)("h2",{id:"tracking-data-that-is-not-event-type-specific"},"Tracking data that is not event-type specific"),(0,i.kt)("p",null,"Some data, such as that relating to the user whose activity is being tracked, is relevant across all event types. The tracker provides two mechanisms for tracking this kind of data."),(0,i.kt)("p",null,"Certain properties, including ",(0,i.kt)("inlineCode",{parentName:"p"},"userId")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"ipAddress"),', can be set as "atomic" properties in the raw event, using the ',(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," class."),(0,i.kt)("p",null,'A more general and powerful method is to attach self-describing JSON "context entities" to your events - the same JSON schemas as used for self-describing events. This means that any data that can be described by a JSON schema can be added to any or all of your events. Read more on the ',(0,i.kt)("a",{parentName:"p",href:"/docs/collecting-data/collecting-from-own-applications/mobile-trackers/custom-tracking-using-schemas/"},"next page"),"."),(0,i.kt)("p",null,"All events also provide the option for setting a custom timestamp, called ",(0,i.kt)("inlineCode",{parentName:"p"},"trueTimestamp"),". See below for details."),(0,i.kt)("h3",{id:"adding-custom-timestamps-to-events"},"Adding custom timestamps to events"),(0,i.kt)("p",null,"Snowplow events have several timestamps. The raw event payload always contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"deviceCreatedTimestamp")," (",(0,i.kt)("inlineCode",{parentName:"p"},"dtm"),") and a ",(0,i.kt)("inlineCode",{parentName:"p"},"deviceSentTimestamp")," (",(0,i.kt)("inlineCode",{parentName:"p"},"stm"),"). Other timestamps are added as the event moves through the pipeline."),(0,i.kt)("p",null,"Every ",(0,i.kt)("inlineCode",{parentName:"p"},"Event")," in the tracker allows for a custom timestamp, called ",(0,i.kt)("inlineCode",{parentName:"p"},"trueTimestamp")," to be set. Read more about timestamps in ",(0,i.kt)("a",{parentName:"p",href:"https://discourse.snowplowanalytics.com/t/which-timestamp-is-the-best-to-see-when-an-event-occurred/538"},"this still relevant forums post"),". "),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"trueTimestamp")," can be added to any event using the ",(0,i.kt)("inlineCode",{parentName:"p"},"trueTimestamp()")," method:"),(0,i.kt)(r.Z,{groupId:"platform",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"ios",label:"iOS",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},'// This example shows a self-describing event, but all events can have a trueTimestamp\nlet event = SelfDescribing(schema: "iglu:com.snowplowanalytics.snowplow/link_click/jsonschema/1-0-1", payload: data)\n    .trueTimestamp(Date(timeIntervalSince1970: 166184300))\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"trueTimestamp")," should be a ",(0,i.kt)("inlineCode",{parentName:"p"},"Date")," object.")),(0,i.kt)(o.Z,{value:"android",label:"Android",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// This example shows a self-describing event, but all events can have a trueTimestamp\nSelfDescribing event = new SelfDescribing(new SelfDescribingJson("iglu:com.snowplowanalytics.snowplow/link_click/jsonschema/1-0-1", data))\n    .trueTimestamp(166184300L);\n')))))}m.isMDXComponent=!0}}]);